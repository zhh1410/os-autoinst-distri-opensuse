<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>lib/opensusebasetest.pm</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rel='stylesheet' href='./style.css' />
</head>

<body>



<ul id="index"><li><a href="./index.html"><i>&lt;= Back to file list</i></a></li>
  <li>
    <ul>
      <li><a href="#clear_and_verify_console">clear_and_verify_console</a></li>
      <li><a href="#post_run_hook">post_run_hook</a></li>
      <li><a href="#save_and_upload_log">save_and_upload_log</a></li>
      <li><a href="#tar_and_upload_log">tar_and_upload_log</a></li>
      <li><a href="#save_and_upload_systemd_unit_log">save_and_upload_systemd_unit_log</a></li>
      <li><a href="#detect_bsc_1063638">detect_bsc_1063638</a></li>
      <li><a href="#problem_detection">problem_detection</a></li>
      <li><a href="#investigate_yast2_failure">investigate_yast2_failure</a></li>
      <li><a href="#export_logs_basic">export_logs_basic</a></li>
      <li><a href="#export_logs">export_logs</a></li>
      <li><a href="#export_logs_locale">export_logs_locale</a></li>
      <li><a href="#upload_packagekit_logs">upload_packagekit_logs</a></li>
      <li><a href="#set_standard_prompt">set_standard_prompt</a></li>
      <li><a href="#export_logs_desktop">export_logs_desktop</a></li>
      <li><a href="#handle_uefi_boot_disk_workaround">handle_uefi_boot_disk_workaround</a></li>
      <li><a href="#wait_grub">wait_grub</a></li>
      <li><a href="#wait_grub_to_boot_on_local_disk">wait_grub_to_boot_on_local_disk</a></li>
      <li><a href="#handle_pxeboot">handle_pxeboot</a></li>
      <li><a href="#wait_boot_past_bootloader">wait_boot_past_bootloader</a></li>
      <li><a href="#wait_boot">wait_boot</a></li>
      <li><a href="#enter_test_text">enter_test_text</a></li>
      <li><a href="#firewall">firewall</a></li>
      <li><a href="#remount_tmp_if_ro">remount_tmp_if_ro</a></li>
      <li><a href="#select_serial_terminal">select_serial_terminal</a></li>
      <li><a href="#select_user_serial_terminal">select_user_serial_terminal</a></li>
      <li><a href="#upload_coredumps">upload_coredumps</a></li>
      <li><a href="#post_fail_hook">post_fail_hook</a></li>
    </ul>
  </li>
</ul><h1>lib/opensusebasetest.pm</h1>

<h2 id="clear_and_verify_console">clear_and_verify_console</h2>

<pre><code> clear_and_verify_console();</code></pre>

<p>Clear the console and ensure that it really got cleared using a needle.</p>

<h2 id="post_run_hook">post_run_hook</h2>

<pre><code> post_run_hook();</code></pre>

<p>This method will be called after each module finished. It will <b>not</b> get executed when the test module failed. Test modules (or their intermediate base classes) may overwrite this method.</p>

<h2 id="save_and_upload_log">save_and_upload_log</h2>

<pre><code> save_and_upload_log($cmd, $file [, timeout =&gt; $timeout] [, screenshot =&gt; $screenshot] [, noupload =&gt; $noupload]);</code></pre>

<p>Will run <code>$cmd</code> on the SUT (without caring for the return code) and tee the standard output to a file called <code>$file</code>. The <code>$timeout</code> parameter specifies how long <code>$cmd</code> may run. When <code>$cmd</code> returns, the output file will be uploaded to openQA unless <code>$noupload</code> is set. Afterwards a screenshot will be created if <code>$screenshot</code> is set.</p>

<h2 id="tar_and_upload_log">tar_and_upload_log</h2>

<pre><code> tar_and_upload_log($sources, $dest, [, timeout =&gt; $timeout] [, screenshot =&gt; $screenshot] [, noupload =&gt; $noupload]);</code></pre>

<p>Will create an xz compressed tar archive with filename <code>$dest</code> from the folder(s) listed in <code>$sources</code>. The return code of <code>tar</code> will be ignored. The <code>$timeout</code> parameter specifies how long <code>tar</code> may run. When <code>tar</code> returns, the output file will be uploaded to openQA unless <code>$noupload</code> is set. Afterwards a screenshot will be created if <code>$screenshot</code> is set.</p>

<h2 id="save_and_upload_systemd_unit_log">save_and_upload_systemd_unit_log</h2>

<pre><code> save_and_upload_systemd_unit_log($unit);</code></pre>

<p>Saves the journal of the systemd unit <code>$unit</code> to <code>journal_$unit.log</code> and uploads it to openQA.</p>

<h2 id="detect_bsc_1063638">detect_bsc_1063638</h2>

<pre><code> detect_bsc_1063638();</code></pre>

<p>Btrfs maintenance jobs lead to the system being unresponsive and affects SUT&#39;s performance. Not to waste time during investigation of the failures, we would like to detect if such jobs are running, providing a hint why test timed out. This method will create a softfail if such a problem is detected.</p>

<h2 id="problem_detection">problem_detection</h2>

<pre><code> problem_detection();</code></pre>

<p>This method will upload a number of logs and debugging information. This includes a log with all journal errors, a systemd unit plot and the output of rpmverify. The files will be uploaded as a single tarball called <code>problem_detection_logs.tar.xz</code>.</p>

<h2 id="investigate_yast2_failure">investigate_yast2_failure</h2>

<pre><code> investigate_yast2_failure();</code></pre>

<p>Inspect the YaST2 logfile checking for known issues.</p>

<h2 id="export_logs_basic">export_logs_basic</h2>

<pre><code> export_logs_basic();</code></pre>

<p>Upload logs that make sense for any failure. This includes <code>/proc/loadavg</code>, <code>ps axf</code>, complete journal since last boot, <code>dmesg</code> and <code>/etc/sysconfig</code>.</p>

<h2 id="export_logs">export_logs</h2>

<pre><code> export_logs();</code></pre>

<p>This method will call several other log gathering methods from this class.</p>

<h2 id="export_logs_locale">export_logs_locale</h2>

<pre><code> export_logs_locale();</code></pre>

<p>Upload logs related to system locale settings. This includes <code>locale</code>, <code>localectl</code> and <code>/etc/vconsole.conf</code>.</p>

<h2 id="upload_packagekit_logs">upload_packagekit_logs</h2>

<pre><code> upload_packagekit_logs();</code></pre>

<p>Upload <code>/var/log/pk_backend_zypp</code>.</p>

<h2 id="set_standard_prompt">set_standard_prompt</h2>

<pre><code> set_standard_prompt();</code></pre>

<p>Set a simple reproducible prompt for easier needle matching without hostname.</p>

<h2 id="export_logs_desktop">export_logs_desktop</h2>

<pre><code> export_logs_desktop();</code></pre>

<p>Upload several KDE, GNOME, X11, GDM and SDDM related logs and configs.</p>

<h2 id="handle_uefi_boot_disk_workaround">handle_uefi_boot_disk_workaround</h2>

<pre><code> handle_uefi_boot_disk_workaround();</code></pre>

<p>Our aarch64 setup fails to boot properly from an installed hard disk so point the firmware boot manager to the right file.</p>

<h2 id="wait_grub">wait_grub</h2>

<pre><code> wait_grub([bootloader_time =&gt; $bootloader_time] [,in_grub =&gt; $in_grub]);</code></pre>

<p>Makes sure the bootloader appears. Returns successfully when reached the bootloader menu, ready to control it further or continue. The time waiting for the bootloader can be configured with <code>$bootloader_time</code> in seconds. Set <code>$in_grub</code> to 1 when the SUT is already expected to be within the grub menu.</p>

<h2 id="wait_grub_to_boot_on_local_disk">wait_grub_to_boot_on_local_disk</h2>

<pre><code> wait_grub_to_boot_on_local_disk</code></pre>

<p>When bootloader appears, make sure to boot from local disk when it is on aarch64.</p>

<h2 id="handle_pxeboot">handle_pxeboot</h2>

<pre><code> handle_pxeboot(bootloader_time =&gt; $bootloader_time, pxemenu =&gt; $pxemenu, pxeselect =&gt; $pxeselect);</code></pre>

<p>Handle a textmode PXE bootloader menu by means of two needle tags: <code>$pxemenu</code> to match the initial menu, <code>$pxeselect</code> to match the menu with the desired entry selected.</p>

<h2 id="wait_boot_past_bootloader">wait_boot_past_bootloader</h2>

<pre><code> wait_boot_past_bootloader([, textmode =&gt; $textmode] [,ready_time =&gt; $ready_time] [, nologin =&gt; $nologin] [, forcenologin =&gt; $forcenologin]);</code></pre>

<p>Waits until the system is booted, every step after the bootloader or bootloader menu. Returns successfully when the system is ready on a login prompt or logged in desktop. Set <code>$textmode</code> to 1 when the text mode login prompt should be expected rather than a desktop or display manager. Expects already unlocked encrypted disks, see <code>wait_boot</code> for handling these in before. The time waiting for the system to be fully booted can be configured with <code>$ready_time</code> in seconds. <code>$forcenologin</code> makes this function behave as if the env var NOAUTOLOGIN was set.</p>

<h2 id="wait_boot">wait_boot</h2>

<pre><code> wait_boot([bootloader_time =&gt; $bootloader_time] [, textmode =&gt; $textmode] [,ready_time =&gt; $ready_time] [,in_grub =&gt; $in_grub] [, nologin =&gt; $nologin] [, forcenologin =&gt; $forcenologin]);</code></pre>

<p>Makes sure the bootloader appears and then boots to desktop or text mode correspondingly. Returns successfully when the system is ready on a login prompt or logged in desktop. Set <code>$textmode</code> to 1 when the text mode login prompt should be expected rather than a desktop or display manager. <code>wait_boot</code> also handles unlocking encrypted disks if needed as well as various exceptions during the boot process. Also, before the bootloader menu or login prompt various architecture or machine specific handlings are in place. The time waiting for the bootloader can be configured with <code>$bootloader_time</code> in seconds as well as the time waiting for the system to be fully booted with <code>$ready_time</code> in seconds. Set <code>$in_grub</code> to 1 when the SUT is already expected to be within the grub menu. <code>wait_boot</code> continues from there. <code>$forcenologin</code> makes this function behave as if the env var NOAUTOLOGIN was set.</p>

<h2 id="enter_test_text">enter_test_text</h2>

<pre><code> enter_test_text($name [, cmd =&gt; $cmd] [, slow =&gt; $slow]);</code></pre>

<p>For testing a text editor or terminal emulator. This will type some newlines and then enter the following text:</p>

<pre><code> If you can see this text $name is working.</code></pre>

<p><code>$name</code> will default to &quot;<i>your program</i>&quot;. If <code>$slow</code> is set, the typing will be very slow. If <code>$cmd</code> is set, the text will be prefixed by an <code>echo</code> command.</p>

<h2 id="firewall">firewall</h2>

<pre><code> firewall();</code></pre>

<p>Return the default expected firewall implementation depending on the product under test, the version and if the SUT is an upgrade.</p>

<h2 id="remount_tmp_if_ro">remount_tmp_if_ro</h2>

<pre><code> remount_tmp_if_ro();</code></pre>

<p>Mounts /tmp to shared memory if not possible to write to tmp. For example, save_y2logs creates temporary files there.</p>

<h2 id="select_serial_terminal">select_serial_terminal</h2>

<pre><code> select_serial_terminal($root);</code></pre>

<p>Select most suitable text console with root user. The choice is made by BACKEND and other variables.</p>

<p>Purpose of this wrapper is to avoid if/else conditions when selecting console.</p>

<p>Optional <code>root</code> parameter specifies, whether use root user (<code>root</code>=1, also default when parameter not specified) or prefer non-root user if available.</p>

<p>Variables affecting behavior: <code>VIRTIO_CONSOLE</code>=0 disables virtio console (use {root,user}-console instead of the default {root-,}virtio-terminal) NOTE: virtio console is enabled by default (<code>VIRTIO_CONSOLE</code>=1). For ppc64le it requires to call prepare_serial_console() to before first use (used in console/system_prepare and shutdown/cleanup_before_shutdown modules) and console=hvc0 in kernel parameters (add it to autoyast profile or update grub setup manually with add_grub_cmdline_settings()).</p>

<p><code>SERIAL_CONSOLE</code>=0 disables serial console (use {root,user}-console instead of the default {root-,}sut-serial) NOTE: serial console is disabled by default on all but s390x machines (<code>SERIAL_CONSOLE</code>=0), because it&#39;s not working yet on other machines (see poo#55985). For s390x it requires console=ttysclp0 in kernel parameters (add it to autoyast profile or update grub setup manually with add_grub_cmdline_settings()).</p>

<p>On ikvm|ipmi|spvm|pvm_hmc it&#39;s expected, that use_ssh_serial_console() has been called (done via activate_console()) therefore SERIALDEV has been set and we can use root-ssh console directly.</p>

<h2 id="select_user_serial_terminal">select_user_serial_terminal</h2>

<pre><code> select_user_serial_terminal();</code></pre>

<p>Select most suitable text console with non-root user. The choice is made by BACKEND and other variables.</p>

<h2 id="upload_coredumps">upload_coredumps</h2>

<pre><code> upload_coredumps();</code></pre>

<p>Upload all coredumps to logs</p>

<h2 id="post_fail_hook">post_fail_hook</h2>

<pre><code> post_fail_hook();</code></pre>

<p>When the test module fails, this method will be called. It will try to fetch some logs from the SUT. Test modules (or their intermediate base classes) may overwrite this method to export certain specific logfiles and call the base method using <code>$self-&gt;SUPER::post_fail_hook;</code> at the end.</p>


</body>

</html>


